{
  "chunks": [
    {
      "filename": "Nuclei_README.md",
      "metadata": {
        "path": "static/Nuclei_README.md"
      },
      "content": "Nuclei is used to send requests across targets based on a template, leading to zero false positives and providing fast scanning on a large number of hosts. Nuclei offers scanning for a variety of protocols, including TCP, DNS, HTTP, SSL, File, Whois, Websocket, Headless etc. With powerful and flexible templating, Nuclei can be used to model all kinds of security checks.We have a [dedicated repository](https://github.com/projectdiscovery/nuclei-templates) that houses various type of vulnerability templates contributed by **more than 300** security researchers and engineers."
    },
    {
      "filename": "Nuclei_README.md",
      "metadata": {
        "path": "static/Nuclei_README.md"
      },
      "content": "#. Nuclei_README.md\n##. Install Nuclei\n\nNuclei requires **go1.20** to install successfully. Run the following command to install the latest version -\n\n```sh\ngo install -v github.com/projectdiscovery/nuclei/v2/cmd/nuclei@latest\n```\n\n\n```sh\nbrew install nuclei\n```\n\n\n```sh\ndocker pull projectdiscovery/nuclei:latest\n```\n**More installation [methods can be found here](https://nuclei.projectdiscovery.io/nuclei/get-started/).**"
    },
    {
      "filename": "Nuclei_README.md",
      "metadata": {
        "path": "static/Nuclei_README.md"
      },
      "content": "#. Nuclei_README.md\n##. Install Nuclei\n###. Nuclei Templates\n\nNuclei has built-in support for automatic template download/update as default since version [v2.5.2](https://github.com/projectdiscovery/nuclei/releases/tag/v2.5.2). [**Nuclei-Templates**](https://github.com/projectdiscovery/nuclei-templates) project provides a community-contributed list of ready-to-use templates that is constantly updated.You may still use the `update-templates` flag to update the nuclei templates at any time; You can write your own checks for your individual workflow and needs following Nuclei's [templating guide](https://nuclei.projectdiscovery.io/templating-guide/).The YAML DSL reference syntax is available [here](SYNTAX-REFERENCE.md)."
    },
    {
      "filename": "Nuclei_README.md",
      "metadata": {
        "path": "static/Nuclei_README.md"
      },
      "content": "#. Nuclei_README.md\n##. Usage\n\n\n\n```sh\nnuclei -h\n```\nThis will display help for the tool. Here are all the switches it supports.\n\n```console\nNuclei is a fast, template based vulnerability scanner focusing\non extensive configurability, massive extensibility and ease of use.\n\nUsage:\n  ./nuclei [flags]\n\nFlags:\nTARGET:\n   -u, -target string[]       target URLs/hosts to scan\n   -l, -list string           path to file containing a list of target URLs/hosts to scan (one per line)\n   -resume string             resume scan using resume.cfg (clustering will be disabled)\n   -sa, -scan-all-ips         scan all the IP's associated with dns record\n   -iv, -ip-version string[]  IP version to scan of hostname (4,6) - (default 4)\n\nTEMPLATES:\n   -nt, -new-templates                    run only new templates added in latest nuclei-templates release\n   -ntv, -new-templates-version string[]  run new templates added in specific version\n   -as, -automatic-scan                   automatic web scan using wappalyzer technology detection to tags mapping\n   -t, -templates string[]                list of template or template directory to run (comma-separated, file)\n   -tu, -template-url string[]            list of template urls to run (comma-separated, file)\n   -w, -workflows string[]                list of workflow or workflow directory to run (comma-separated, file)\n   -wu, -workflow-url string[]            list of workflow urls to run (comma-separated, file)\n   -validate                              validate the passed templates to nuclei\n   -nss, -no-strict-syntax                disable strict syntax check on templates\n   -td, -template-display                 displays the templates content\n   -tl                                    list all available templates\n\nFILTERING:\n   -a, -author string[]               templates to run based on authors (comma-separated, file)\n   -tags string[]                     templates to run based on tags (comma-separated, file)\n   -etags, -exclude-tags string[]     templates to exclude based on tags (comma-separated, file)\n   -itags, -include-tags string[]     tags to be executed even if they are excluded either by default or configuration\n   -id, -template-id string[]         templates to run based on template ids (comma-separated, file)\n   -eid, -exclude-id string[]         templates to exclude based on template ids (comma-separated, file)\n   -it, -include-templates string[]   templates to be executed even if they are excluded either by default or configuration\n   -et, -exclude-templates string[]   template or template directory to exclude (comma-separated, file)\n   -em, -exclude-matchers string[]    template matchers to exclude in result\n   -s, -severity value[]              templates to run based on severity. Possible values: info, low, medium, high, critical, unknown\n   -es, -exclude-severity value[]     templates to exclude based on severity. Possible values: info, low, medium, high, critical, unknown\n   -pt, -type value[]                 templates to run based on protocol type. Possible values: dns, file, http, headless, tcp, workflow, ssl, websocket, whois\n   -ept, -exclude-type value[]        templates to exclude based on protocol type. Possible values: dns, file, http, headless, tcp, workflow, ssl, websocket, whois\n   -tc, -template-condition string[]  templates to run based on expression condition\n\nOUTPUT:\n   -o, -output string            output file to write found issues/vulnerabilities\n   -sresp, -store-resp           store all request/response passed through nuclei to output directory\n   -srd, -store-resp-dir string  store all request/response passed through nuclei to custom directory (default \"output\")\n   -silent                       display findings only\n   -nc, -no-color                disable output content coloring (ANSI escape codes)\n   -j, -jsonl                    write output in JSONL(ines) format\n   -irr, -include-rr             include request/response pairs in the JSONL output (for findings only)\n   -nm, -no-meta                 disable printing result metadata in cli output\n   -ts, -timestamp               enables printing timestamp in cli output\n   -rdb, -report-db string       nuclei reporting database (always use this to persist report data)\n   -ms, -matcher-status          display match failure status\n   -me, -markdown-export string  directory to export results in markdown format\n   -se, -sarif-export string     file to export results in SARIF format\n   -je, -json-export string      file to export results in JSON format\n   -jle, -jsonl-export string    file to export results in JSONL(ine) format\n\nCONFIGURATIONS:\n   -config string                 path to the nuclei configuration file\n   -fr, -follow-redirects         enable following redirects for http templates\n   -fhr, -follow-host-redirects   follow redirects on the same host\n   -mr, -max-redirects int        max number of redirects to follow for http templates (default 10)\n   -dr, -disable-redirects        disable redirects for http templates\n   -rc, -report-config string     nuclei reporting module configuration file\n   -H, -header string[]           custom header/cookie to include in all http request in header:value format (cli, file)\n   -V, -var value                 custom vars in key=value format\n   -r, -resolvers string          file containing resolver list for nuclei\n   -sr, -system-resolvers         use system DNS resolving as error fallback\n   -dc, -disable-clustering       disable clustering of requests\n   -passive                       enable passive HTTP response processing mode\n   -fh2, -force-http2             force http2 connection on requests\n   -ev, -env-vars                 enable environment variables to be used in template\n   -cc, -client-cert string       client certificate file (PEM-encoded) used for authenticating against scanned hosts\n   -ck, -client-key string        client key file (PEM-encoded) used for authenticating against scanned hosts\n   -ca, -client-ca string         client certificate authority file (PEM-encoded) used for authenticating against scanned hosts\n   -sml, -show-match-line         show match lines for file templates, works with extractors only\n   -ztls                          use ztls library with autofallback to standard one for tls13\n   -sni string                    tls sni hostname to use (default: input domain name)\n   -sandbox                       sandbox nuclei for safe templates execution\n   -i, -interface string          network interface to use for network scan\n   -at, -attack-type string       type of payload combinations to perform (batteringram,pitchfork,clusterbomb)\n   -sip, -source-ip string        source ip address to use for network scan\n   -config-directory string       override the default config path ($home/.config)\n   -rsr, -response-size-read int  max response size to read in bytes (default 10485760)\n   -rss, -response-size-save int  max response size to read in bytes (default 1048576)\n   -reset                         reset removes all nuclei configuration and data files (including nuclei-templates)\n\nINTERACTSH:\n   -iserver, -interactsh-server string  interactsh server url for self-hosted instance (default: oast.pro,oast.live,oast.site,oast.online,oast.fun,oast.me)\n   -itoken, -interactsh-token string    authentication token for self-hosted interactsh server\n   -interactions-cache-size int         number of requests to keep in the interactions cache (default 5000)\n   -interactions-eviction int           number of seconds to wait before evicting requests from cache (default 60)\n   -interactions-poll-duration int      number of seconds to wait before each interaction poll request (default 5)\n   -interactions-cooldown-period int    extra time for interaction polling before exiting (default 5)\n   -ni, -no-interactsh                  disable interactsh server for OAST testing, exclude OAST based templates\n\nFUZZING:\n   -ft, -fuzzing-type string  overrides fuzzing type set in template (replace, prefix, postfix, infix)\n   -fm, -fuzzing-mode string  overrides fuzzing mode set in template (multiple, single)\n\nUNCOVER:\n   -uc, -uncover                  enable uncover engine\n   -uq, -uncover-query string[]   uncover search query\n   -ue, -uncover-engine string[]  uncover search engine (shodan,shodan-idb,fofa,censys,quake,hunter,zoomeye,netlas,criminalip) (default shodan)\n   -uf, -uncover-field string     uncover fields to return (ip,port,host) (default \"ip:port\")\n   -ul, -uncover-limit int        uncover results to return (default 100)\n   -ucd, -uncover-delay int       delay between uncover query requests in seconds (0 to disable) (default 1)\n\nRATE-LIMIT:\n   -rl, -rate-limit int               maximum number of requests to send per second (default 150)\n   -rlm, -rate-limit-minute int       maximum number of requests to send per minute\n   -bs, -bulk-size int                maximum number of hosts to be analyzed in parallel per template (default 25)\n   -c, -concurrency int               maximum number of templates to be executed in parallel (default 25)\n   -hbs, -headless-bulk-size int      maximum number of headless hosts to be analyzed in parallel per template (default 10)\n   -headc, -headless-concurrency int  maximum number of headless templates to be executed in parallel (default 10)\n\nOPTIMIZATIONS:\n   -timeout int                        time to wait in seconds before timeout (default 10)\n   -retries int                        number of times to retry a failed request (default 1)\n   -ldp, -leave-default-ports          leave default HTTP/HTTPS ports (eg. host:80,host:443)\n   -mhe, -max-host-error int           max errors for a host before skipping from scan (default 30)\n   -te, -track-error string[]          adds given error to max-host-error watchlist (standard, file)\n   -nmhe, -no-mhe                      disable skipping host from scan based on errors\n   -project                            use a project folder to avoid sending same request multiple times\n   -project-path string                set a specific project path (default \"/tmp\")\n   -spm, -stop-at-first-match          stop processing HTTP requests after the first match (may break template/workflow logic)\n   -stream                             stream mode - start elaborating without sorting the input\n   -ss, -scan-strategy value           strategy to use while scanning(auto/host-spray/template-spray) (default auto)\n   -irt, -input-read-timeout duration  timeout on input read (default 3m0s)\n   -nh, -no-httpx                      disable httpx probing for non-url input\n   -no-stdin                           disable stdin processing\n\nHEADLESS:\n   -headless                    enable templates that require headless browser support (root user on Linux will disable sandbox)\n   -page-timeout int            seconds to wait for each page in headless mode (default 20)\n   -sb, -show-browser           show the browser on the screen when running templates with headless mode\n   -sc, -system-chrome          use local installed Chrome browser instead of nuclei installed\n   -lha, -list-headless-action  list available headless actions\n\nDEBUG:\n   -debug                    show all requests and responses\n   -dreq, -debug-req         show all sent requests\n   -dresp, -debug-resp       show all received responses\n   -p, -proxy string[]       list of http/socks5 proxy to use (comma separated or file input)\n   -pi, -proxy-internal      proxy all internal requests\n   -ldf, -list-dsl-function  list all supported DSL function signatures\n   -tlog, -trace-log string  file to write sent requests trace log\n   -elog, -error-log string  file to write sent requests error log\n   -version                  show nuclei version\n   -hm, -hang-monitor        enable nuclei hang monitoring\n   -v, -verbose              show verbose output\n   -profile-mem string       optional nuclei memory profile dump file\n   -vv                       display templates loaded for scan\n   -svd, -show-var-dump      show variables dump for debugging\n   -ep, -enable-pprof        enable pprof debugging server\n   -tv, -templates-version   shows the version of the installed nuclei-templates\n   -hc, -health-check        run diagnostic check up\n\nUPDATE:\n   -up, -update                      update nuclei engine to the latest released version\n   -ut, -update-templates            update nuclei-templates to latest released version\n   -ud, -update-template-dir string  custom directory to install / update nuclei-templates\n   -duc, -disable-update-check       disable automatic nuclei/templates update check\n\nSTATISTICS:\n   -stats                    display statistics about the running scan\n   -sj, -stats-json          display statistics in JSONL(ines) format\n   -si, -stats-interval int  number of seconds to wait between showing a statistics update (default 5)\n   -m, -metrics              expose nuclei metrics on a port\n   -mp, -metrics-port int    port to expose nuclei metrics on (default 9092)\n\nCLOUD:\n   -cloud                              run scan on nuclei cloud\n   -ads, -add-datasource string        add specified data source (s3,github)\n   -atr, -add-target string            add target(s) to cloud\n   -atm, -add-template string          add template(s) to cloud\n   -lsn, -list-scan                    list previous cloud scans\n   -lso, -list-output string           list scan output by scan id\n   -ltr, -list-target                  list cloud target by id\n   -ltm, -list-template                list cloud template by id\n   -lds, -list-datasource              list cloud datasource by id\n   -lrs, -list-reportsource            list reporting sources\n   -dsn, -delete-scan string           delete cloud scan by id\n   -dtr, -delete-target string         delete target(s) from cloud\n   -dtm, -delete-template string       delete template(s) from cloud\n   -dds, -delete-datasource string     delete specified data source\n   -drs, -disable-reportsource string  disable specified reporting source\n   -ers, -enable-reportsource string   enable specified reporting source\n   -gtr, -get-target string            get target content by id\n   -gtm, -get-template string          get template content by id\n   -nos, -no-store                     disable scan/output storage on cloud\n   -no-tables                          do not display pretty-printed tables\n   -limit int                          limit the number of output to display (default 100)\n```"
    },
    {
      "filename": "Nuclei_README.md",
      "metadata": {
        "path": "static/Nuclei_README.md"
      },
      "content": "#. Nuclei_README.md\n##. Running Nuclei\n\nScanning target domain with [community-curated](https://github.com/projectdiscovery/nuclei-templates) nuclei templates.\n\n```sh\nnuclei -u https://example.com\n```\nScanning target URLs with [community-curated](https://github.com/projectdiscovery/nuclei-templates) nuclei templates.\n\n```sh\nnuclei -list urls.txt\n```\nExample of `urls.txt`:\n\n```yaml\nhttp://example.com\nhttp://app.example.com\nhttp://test.example.com\nhttp://uat.example.com\n```\n**More detailed examples of running nuclei can be found [here](https://nuclei.projectdiscovery.io/nuclei/get-started/#running-nuclei).**"
    },
    {
      "filename": "Nuclei_README.md",
      "metadata": {
        "path": "static/Nuclei_README.md"
      },
      "content": "#. Nuclei_README.md\n##. For Security Engineers\n\nNuclei offers great number of features that are helpful for security engineers to customise workflow in their organization. With the varieties of scan capabilities (like DNS, HTTP, TCP), security engineers can easily create their suite of custom checks with Nuclei.Varieties of protocols supported: TCP, DNS, HTTP, File, etc\nAchieve complex vulnerability steps with workflows and dynamic requests.\nEasy to integrate into CI/CD, designed to be easily integrated into regression cycle to actively check the fix and re-appearance of vulnerability.\n**For Bug Bounty hunters:**Nuclei allows you to customise your testing approach with your own suite of checks and easily run across your bug bounty programs. Moreover, Nuclei can be easily integrated into any continuous scanning workflow.Designed to be easily integrated into other tool workflow.\nCan process thousands of hosts in few minutes.\nEasily automate your custom testing approach with our simple YAML DSL.\nPlease check our other open-source projects that might fit into your bug bounty workflow: [github.com/projectdiscovery](http://github.com/projectdiscovery), we also host daily [refresh of DNS data at Chaos](http://chaos.projectdiscovery.io).**For Penetration Testers:**Nuclei immensely improve how you approach security assessment by augmenting the manual, repetitive processes. Consultancies are already converting their manual assessment steps with Nuclei, it allows them to run set of their custom assessment approach across thousands of hosts in an automated manner.Pen-testers get the full power of our public templates and customization capabilities to speed up their assessment process, and specifically with the regression cycle where you can easily verify the fix.Easily create your compliance, standards suite (e.g. OWASP Top 10) checklist.\nWith capabilities like fuzz and workflows, complex manual steps and repetitive assessment can be easily automated with Nuclei.\nEasy to re-test vulnerability-fix by just re-running the template."
    },
    {
      "filename": "Nuclei_README.md",
      "metadata": {
        "path": "static/Nuclei_README.md"
      },
      "content": "#. Nuclei_README.md\n##. For Developers and Organizations\n\nNuclei is built with simplicity in mind, with the community backed templates by hundreds of security researchers, it allows you to stay updated with the latest security threats using continuous Nuclei scanning on the hosts. It is designed to be easily integrated into regression tests cycle, to verify the fixes and eliminate vulnerabilities from occurring in the future.CI/CD: Engineers are already utilising Nuclei within their CI/CD pipeline, it allows them to constantly monitor their staging and production environments with customised templates.\nContinuous Regression Cycle: With Nuclei, you can create your custom template on every new identified vulnerability and put into Nuclei engine to eliminate in the continuous regression cycle.\nWe have [a discussion thread around this](https://github.com/projectdiscovery/nuclei-templates/discussions/693), there are already some bug bounty programs giving incentives to hackers on writing nuclei templates with every submission, that helps them to eliminate the vulnerability across all their assets, as well as to eliminate future risk in reappearing on productions. If you're interested in implementing it in your organization, feel free to [reach out to us](mailto:contact@projectdiscovery.io). We will be more than happy to help you in the getting started process, or you can also post into the [discussion thread for any help](https://github.com/projectdiscovery/nuclei-templates/discussions/693)."
    },
    {
      "filename": "Nuclei_README.md",
      "metadata": {
        "path": "static/Nuclei_README.md"
      },
      "content": "#. Nuclei_README.md\n##. For Developers and Organizations\n###. Using Nuclei From Go Code\n\nExamples of using Nuclei From Go Code to run templates on targets are provided in the [examples](v2/examples/) folder."
    },
    {
      "filename": "Nuclei_README.md",
      "metadata": {
        "path": "static/Nuclei_README.md"
      },
      "content": "#. Nuclei_README.md\n##. Resources\n\nFinding bugs with Nuclei with PinkDraconian (Robbe Van Roey) by @PinkDraconian\nNuclei: Packing a Punch with Vulnerability Scanning by Bishopfox\nThe WAF efficacy framework by Fastly\nScanning Live Web Applications with Nuclei in CI/CD Pipeline by @TristanKalos\nCommunity Powered Scanning with Nuclei\nNuclei Unleashed - Quickly write complex exploits\nNuclei - Fuzz all the things\nNuclei + Interactsh Integration for Automating OOB Testing\nWeaponizes nuclei Workflows to Pwn All the Things by @dwisiswant0\nHow to Scan Continuously with Nuclei? by @dwisiswant0\nHack with Automation !!! by @DhiyaneshGeek"
    },
    {
      "filename": "Nuclei_README.md",
      "metadata": {
        "path": "static/Nuclei_README.md"
      },
      "content": "#. Nuclei_README.md\n##. Credits\n\nThanks to all the amazing [community contributors for sending PRs](https://github.com/projectdiscovery/nuclei/graphs/contributors) and keeping this project updated. :heart:If you have an idea or some kind of improvement, you are welcome to contribute and participate in the Project, feel free to send your PR.Do also check out the below similar open-source projects that may fit in your workflow:[FFuF](https://github.com/ffuf/ffuf), [Qsfuzz](https://github.com/ameenmaali/qsfuzz), [Inception](https://github.com/proabiral/inception), [Snallygaster](https://github.com/hannob/snallygaster), [Gofingerprint](https://github.com/Static-Flow/gofingerprint), [Sn1per](https://github.com/1N3/Sn1per/tree/master/templates), [Google tsunami](https://github.com/google/tsunami-security-scanner), [Jaeles](https://github.com/jaeles-project/jaeles), [ChopChop](https://github.com/michelin/ChopChop)"
    },
    {
      "filename": "Nuclei_README.md",
      "metadata": {
        "path": "static/Nuclei_README.md"
      },
      "content": "#. Nuclei_README.md\n##. License\n\nNuclei is distributed under [MIT License](https://github.com/projectdiscovery/nuclei/blob/main/LICENSE.md)"
    },
    {
      "filename": "multiprotocol.md",
      "metadata": {
        "path": "static/multiprotocol.md"
      },
      "content": "#. multiprotocol.md\n###. Multi Protocol Execution\n\nNuclei supports many protocol such as HTTP,DNS,Network etc and one can write nuclei template for a vulnerability in any of these protocols, but what if a vulnerability requires execution of multiple protocols in sync to test/exploit it. A classic example of this is **Subdomain Takeovers** where one needs to check for CNAME record of a subdomain and then check if the service is vulnerable to takeover or not. This was partially possible in nuclei with workflows but with **Nuclei v3.0** it is now possible to easily write a **Template** that can execute multiple protocols in sync and then perform checks on the results of each protocol along with other improvements."
    },
    {
      "filename": "multiprotocol.md",
      "metadata": {
        "path": "static/multiprotocol.md"
      },
      "content": "#. multiprotocol.md\n###. Multi Protocol Execution\n####. Example\n\n\n\n```yaml\nid: dns-http-template\n\ninfo:\n  name: dns + http takeover template\n  author: pdteam\n  severity: info\n\ndns:\n  - name: \"{{FQDN}}\" # DNS Request\n    type: cname\n\n    extractors:\n      - type: dsl\n        name: exported_cname\n        dsl:\n          - cname\n        internal: true\n\nhttp:\n  - method: GET # http request\n    path:\n      - \"{{BaseURL}}\"\n\n    matchers:\n      - type: dsl\n        dsl:\n          - contains(body,'Domain not found') # check for http string\n          - contains(exported_cname, 'github.io') # check for cname (extracted information from dns response)\n        condition: and\n```\nAs we can see in above example there is no new logic or syntax just write logic for each protocol and then use [dynamic extractor](./operators/extractors.md#dynamic-extractor) to export that variable and it is shared across all protocols and we call this **Template Context** which contains all variables that are scoped at template Level."
    },
    {
      "filename": "multiprotocol.md",
      "metadata": {
        "path": "static/multiprotocol.md"
      },
      "content": "#. multiprotocol.md\n###. Features\n\n!!! example  \"Features that make multi protocol execution powerful\"\n```\n* Export Data Using Dynamic Extractors\n* Template Scoped Protocol Responses\n* Shared Variables Across Protocols\n\n```"
    },
    {
      "filename": "multiprotocol.md",
      "metadata": {
        "path": "static/multiprotocol.md"
      },
      "content": "#. multiprotocol.md\n##. Export Data Using Dynamic Extractors\n\nIf you are not familiar with dynamic extractors then please read [dynamic extractor](./operators/extractors.md#dynamic-extractor) section first.Earlier Dynamic Extractors support was only available for specific protocol or Workflows but with multi protocol execution dynamic extracted values are stored in template context and can be used across all protocols."
    },
    {
      "filename": "multiprotocol.md",
      "metadata": {
        "path": "static/multiprotocol.md"
      },
      "content": "#. multiprotocol.md\n##. Export Data Using Dynamic Extractors\n###. Example\n\n\n\n```yaml\nid: dns-http-template\n\ninfo:\n  name: dns + http takeover template\n  author: pdteam\n  severity: info\n\ndns:\n  - name: \"{{FQDN}}\" # DNS Request\n    type: cname\n\n    extractors:\n      - type: dsl\n        name: exported_cname\n        dsl:\n          - cname\n        internal: true\n\nhttp:\n  - method: GET # http request\n    path:\n      - \"{{BaseURL}}\"\n\n    matchers:\n      - type: dsl\n        dsl:\n          - contains(body,'Domain not found') # check for http string\n          - contains(exported_cname, 'github.io') # check for cname (extracted information from dns response)\n        condition: and\n```"
    },
    {
      "filename": "multiprotocol.md",
      "metadata": {
        "path": "static/multiprotocol.md"
      },
      "content": "#. multiprotocol.md\n##. Template Scoped Protocol Responses\n\nIn Previous example we saw how to export dns cname and use it in http request but what if there are more than 4 protocols in a template and we want to export `subject_dn`,`ns`,`cname` , `all_headers` and what not. this can be done just by adding more dynamic extractors but that will add lot of noise to template and redundant logic and at some point it will hard to track and maintain all those variables.To address this Multi protocol execution brings support for template scoped protocol responses i.e all response fields of all protocols in template are available in template context with protocol prefix.Ex:| Protocol | Response Field | Exported Variable |\n| -------- | -------------- | ----------------- |\n| ssl      | subject_dn     | ssl_subject_dn    |\n| dns      | ns             | dns_ns            |\n| dns      | cname          | dns_cname         |\n| http     | all_headers    | http_all_headers  |!!! info \"Note\"This is just a example but response fields of all protocols used in multi protocol template are exported"
    },
    {
      "filename": "multiprotocol.md",
      "metadata": {
        "path": "static/multiprotocol.md"
      },
      "content": "#. multiprotocol.md\n##. Template Scoped Protocol Responses\n###. Example\n\n\n\n```yaml\nid: dns-ssl-http-proto-prefix\n\ninfo:\n  name: multi protocol request with response fields\n  author: pdteam\n  severity: info\n\ndns:\n  - name: \"{{FQDN}}\" # DNS Request\n    type: cname\n\nssl:\n  - address: \"{{Hostname}}\" # ssl request\n\nhttp:\n  - method: GET # http request\n    path:\n      - \"{{BaseURL}}\"\n\n    matchers:\n      - type: dsl\n        dsl:\n          - contains(http_body,'ProjectDiscovery.io') # check for http string\n          - trim_suffix(dns_cname,'.ghost.io.') == 'projectdiscovery' # check for cname (extracted information from dns response)\n          - ssl_subject_cn == 'blog.projectdiscovery.io'\n        condition: and\n```\n!!! tip \"List all available response fields\"To list all exported response fields write a multi protocol template and run it with `-debug -svd` flag and it will print all exported response fields\nEx:`nuclei -t multi-protocol-template.yaml -u scanme.sh -debug -svd`"
    },
    {
      "filename": "multiprotocol.md",
      "metadata": {
        "path": "static/multiprotocol.md"
      },
      "content": "#. multiprotocol.md\n##. Shared Variables Across Protocols\n\nAs we can tell now multi protocol execution brings lot of flexibility and power to write complex templates but there are some cases where logic requires some kind of preprocessing to variables before they are used, again this can be achieved by using variables and helper functions directly in request but that will make template ugly and unreadable and this is especially true with network templates.For example consider [Apache Airflow \u003c=1.10.10 - Command Injection](https://github.com/projectdiscovery/nuclei-templates/blob/main/network/cves/2020/CVE-2020-11981.yaml) which requires base64-encoding,decoding,concat,interactsh_urls and then payload is ready to use, if all this logic is implemented in protocol request itself then it will be hard to read and maintain i.e why we have [variables](variables.md), to reuse variables and make payloads readable and easy to maintain, it is also necessary for other cases where generated interactsh urls needs to be same across multiple requests/protocols etc.For this reason multi protocol execution supports [variables](variables.md) and they are also scoped at template context and can be used across all protocols for preprocessing, payload building etc."
    },
    {
      "filename": "multiprotocol.md",
      "metadata": {
        "path": "static/multiprotocol.md"
      },
      "content": "#. multiprotocol.md\n##. Shared Variables Across Protocols\n###. Example\n\n\n\n```yaml\nid: dns-ssl-http-with-variables\n\ninfo:\n  name: multi protocol request with variables\n  author: pdteam\n  severity: info\n\n\nvariables:\n  cname_filtered: '{{trim_suffix(dns_cname,\".ghost.io.\")}}'\n\ndns:\n  - name: \"{{FQDN}}\" # DNS Request\n    type: cname\n\nssl:\n  - address: \"{{Hostname}}\" # ssl request\n\nhttp:\n  - method: GET # http request\n    path:\n      - \"{{BaseURL}}\"\n\n    matchers:\n      - type: dsl\n        dsl:\n          - contains(http_body,'ProjectDiscovery.io') # check for http string\n          - cname_filtered == 'projectdiscovery' # check for cname (extracted information from dns response)\n          - ssl_subject_cn == 'blog.projectdiscovery.io'\n        condition: and\n```\nThe above template and previous one are same but in this case we are using variables to preprocess `dns_cname` and then use it in http request later on!!! info \"Note\"This is just a example of how variables can be used in multi protocol templates, there are many other use cases where variables can be used to make templates more readable and maintainable"
    },
    {
      "filename": "multiprotocol.md",
      "metadata": {
        "path": "static/multiprotocol.md"
      },
      "content": "#. multiprotocol.md\n##. How Multi Protocol Templates Work \u0026 Things to Note\n\nAt this point we have seen how multi protocol templates look like and what are the features it brings to the table. Now let's see how multi protocol templates work and things to keep in mind while writing them.Multi Protocol Templates are executed in order of protocols defined in template\nProtocols in multi protocol templates are executed in serial i.e one after another\nResponse fields of protocols are exported to template context as soon as that protocol is executed\nVariables are scoped at template level and evaluated after each protocol execution\nMulti protocol brings limited indirect support for preprocessing(using variables) and postprocessing(using dynamic extractors+dsl) for protocols"
    },
    {
      "filename": "multiprotocol.md",
      "metadata": {
        "path": "static/multiprotocol.md"
      },
      "content": "#. multiprotocol.md\n##. How Multi Protocol Templates Work \u0026 Things to Note\n###. Known Limitations and Workarounds\n\nCurrently there is no direct way to handle arrays (i.e if exported variable is not just a single element but an array). A possible workaround for this is to index elements of arrayExample consider `ssl_subject_an` which is subject alternative names present in ssl certificate of target, if target has more than 1 Subject Alternative Name then `ssl_subject_an` will be an array of all Subject Alternative Names and assume vulnerabilty needs to check cname records of all Subject Alternative Names then that is not possible directly and only the first element in array is used but if we want to use all elements of array then we can use index to access each element of array starting from 1\n\n```\n// example\n// ssl_subject_an = [github.io,projectdiscovery.io,scanme.sh] then\nssl_subject_an = github.io\nssl_subject_an1 = projectdiscovery.io\nssl_subject_an2 = scanme.sh\n```\n\n\n```yaml\ndns:\n  - name: \"{{ssl_subject_an}}\" # DNS Request\n    type: cname\n  - name: \"{{ssl_subject_an1}}\" # DNS Request\n    type: cname\n  - name: \"{{ssl_subject_an2}}\" # DNS Request\n    type: cname\n  - name: \"{{ssl_subject_an3}}\" # DNS Request\n    type: cname\n```\nIn Above dns request example we are using index to access each element of array and send dns request for each element of array if array only contains 2 elements then last 2 requests are skipped with unresolved variables warning!!! info \"Note\"there are multiple ways to achieve this. An alternative implementation for this is to use `payloads`Features are implemented based on use cases and feedback from community, if you have any usecase that requires improvements to multi protocol execution or regarding array variables then please open a issue with details and proper usecase"
    },
    {
      "filename": "multiprotocol.md",
      "metadata": {
        "path": "static/multiprotocol.md"
      },
      "content": "#. multiprotocol.md\n##. FAQ\n\n??? info \"What Protocols are supported in Multi-Protocol Execution Mode ?\"There is no restriction around any protocol and any protocol available/implemented in nuclei engine can be used in multi protocol templates??? info \"How many protocols can be used in Multi-Protocol Execution Mode ?\"There is no restriction around number of protocols but currently duplicated protocols are not supported i.e dns -\u003e http -\u003e ssl -\u003e http. Please open a issue if you have a vulnerabilty/usecase that requires duplicated protocols??? info \"What happens if a protocol fails ?\"Multi Protocol Execution follows exit on error policy i.e if protocol fails to execute then execution of remaining protocols is skipped and template execution is stopped??? info \"How is multi protocol execution different from workflows ?\"Workflow as name suggest is a workflow that executes templates based on workflow fileWorkflow does not contain actual logic of vulnerability but just a workflow that executes different templates\nWorkflow supports conditional execution of multiple templates\nWorkflow has limited supported for variables and dynamic extractors\nTo summarize workflow is a step higher than template and manages execution of templates based on workflow file??? info \"Is it supported in nuclei v2 ?\"No, Multi Protocol Execution is only supported in nuclei v3 and above"
    },
    {
      "filename": "nuclei.md",
      "metadata": {
        "path": "static/nuclei.md"
      },
      "content": "#. nuclei.md\n###. ??? info \"What is nuclei?\"\n\n\n```\nNuclei is a fast and customizable vulnerability scanner based on simple **YAML-based templates**.\n\nIt has two components, 1) [Nuclei](http://github.com/projectdiscovery/nuclei) engine - the core of the project allows scripting HTTP / DNS / Network / Headless / File protocols based checks in a very simple to read-and-write YAML-based format. 2) Nuclei [templates](http://github.com/projectdiscovery/nuclei-templates) - ready-to-use **community-contributed** vulnerability templates.\n\n```"
    },
    {
      "filename": "nuclei.md",
      "metadata": {
        "path": "static/nuclei.md"
      },
      "content": "#. nuclei.md\n##. ??? info \"What was the genesis behind nuclei?\"\nTraditional scanners always lacked the features to allow easy-to-write custom checks on top of their engine. And this is why we started developing Nuclei with a core focus on simplicity, modularity, and the ability to scan on many assets.\n\n\n```\nWe wanted something simple enough to be used by ==**everyone**== while complex enough to integrate into the modern web with its intricacies. The features implemented in nuclei are tailored to allow very rapid prototyping of complex security checks.\n\n```"
    },
    {
      "filename": "nuclei.md",
      "metadata": {
        "path": "static/nuclei.md"
      },
      "content": "#. nuclei.md\n##. ??? info \"What modules does nuclei engine support?\"\n\n\n```\nNuclei engine supports the following type of modules.\n\n- [HTTP](https://nuclei.projectdiscovery.io/templating-guide/protocols/http/)\n- [DNS](https://nuclei.projectdiscovery.io/templating-guide/protocols/dns/)\n- [TCP](https://nuclei.projectdiscovery.io/templating-guide/protocols/network/)\n- [FILE](https://nuclei.projectdiscovery.io/templating-guide/protocols/file/)\n\n```"
    },
    {
      "filename": "nuclei.md",
      "metadata": {
        "path": "static/nuclei.md"
      },
      "content": "#. nuclei.md\n##. ??? info \"What kind of scans can I perform with nuclei?\"\n\n\n```\nNuclei can be used to detect security vulnerabilities in **Web Applications**, **Networks**, **DNS** based misconfiguration, and **Secrets scanning** in source code or files on the local file system.\n\n```"
    },
    {
      "filename": "nuclei.md",
      "metadata": {
        "path": "static/nuclei.md"
      },
      "content": "#. nuclei.md\n##. ??? info \"How well-maintained is this project?\"\n\n\n```\nThe nuclei project is actively developed and maintained by the [ProjectDiscovery](https://projectdiscovery.io/#/) team, and generally releases every 2 weeks.\n\n```"
    },
    {
      "filename": "nuclei.md",
      "metadata": {
        "path": "static/nuclei.md"
      },
      "content": "#. nuclei.md\n##. ??? tip \"How can I support/contribute to this project? 💙\"\n\n\n```\nTo help keep project momentum, we request everyone to write and share new templates with the community in the [template project](https://github.com/projectdiscovery/nuclei-templates). Please help us maintain this public, ready to use, and up-to-date nuclei template repository.\n\nIf you found an interesting/unique security issue using nuclei and want to share the process walk-through in the form of a blog, we are happy to publish your guest post on the [ProjectDiscovery blog](https://blog.projectdiscovery.io).\n\n```"
    },
    {
      "filename": "nuclei.md",
      "metadata": {
        "path": "static/nuclei.md"
      },
      "content": "#. nuclei.md\n##. ??? warning \"I found results with nuclei. When should I report it?\"\n\n\n```\n**Wait a minute** -- after nuclei detected a security issue, it's always advised to have a second look before reporting it. Here's a tip to confirm/validate the issues.\n\n??? tip \"How do I validate nuclei results?\"\n\n\tOnce nuclei finds a result, and you have vulnerable ==target== and ==template==, rerun the template with ==`-debug`== flag to inspect the output against the expected matcher defined in the template. In this way, you can confirm the identified vulnerability.\n\n```"
    },
    {
      "filename": "nuclei.md",
      "metadata": {
        "path": "static/nuclei.md"
      },
      "content": "#. nuclei.md\n##. ??? warning \"How much traffic does nuclei generate?\"\n\n\n```\nBy default nuclei will make several thousand requests (both HTTP protocol and other services) against a single target when running **all nuclei-templates**. This stems from over 3500 nuclei templates in the [[template releases](https://github.com/projectdiscovery/nuclei-templates/releases/), with more added daily.\n\n!!! info \"\"\n\tAs default, few templates listed [here](https://github.com/projectdiscovery/nuclei-templates/blob/master/.nuclei-ignore) are excluded from default scans.\n\n```"
    },
    {
      "filename": "nuclei.md",
      "metadata": {
        "path": "static/nuclei.md"
      },
      "content": "#. nuclei.md\n##. ??? warning \"Is it safe to run nuclei?\"\n\n\n```\nWe consider two factors in regards to calling nuclei ==\"safe\"== -\n\n1. The **traffic** nuclei makes against the target website.\n2. The **impact** templates have on the target website.\n\n!!! check \"HTTP Traffic\"\n\n\tNuclei usually makes fewer HTTP requests than the number of templates selected for a scan due to its intelligent request reduction. While some templates contain multiple requests, this rule generally holds true across most scan configurations.\n\n!!! check \"Safe Templates\"\n\n\tThe nuclei templates project houses a variety of templates which perform fuzzing and other actions which may result in a DoS against the target system (see [the list here](https://github.com/projectdiscovery/nuclei-templates/blob/master/.nuclei-ignore)). To ensure  these templates are not accidentally run, they are tagged and excluded them from the default scan. These templates can only be executed when explicitly invoked using the `-itags` option.\n\n```"
    },
    {
      "filename": "nuclei.md",
      "metadata": {
        "path": "static/nuclei.md"
      },
      "content": "#. nuclei.md\n##. ??? info \"What is nuclei's license?\"\n\n\n```\nNuclei is an open-source project distributed under the [MIT License](https://github.com/projectdiscovery/nuclei/blob/master/LICENSE.md).\n\n```"
    },
    {
      "filename": "nuclei.md",
      "metadata": {
        "path": "static/nuclei.md"
      },
      "content": "#. nuclei.md\n##. ??? info \"I have more questions! 🙋\"\n\n\n```\nPlease join our [Discord server](https://discord.gg/projectdiscovery), or contact us via [Twitter](http://twitter.com/pdnuclei).\n\n```"
    },
    {
      "filename": "nuclei.md",
      "metadata": {
        "path": "static/nuclei.md"
      },
      "content": "#. nuclei.md\n##. ??? warning \"Missing dependencies in headless mode on Linux\"\n\n\n```\nHeadless mode on machines based on Linux (OS or containers, eg. Docker) might face runtime errors due to missing dependencies related to specific OS-shared libraries used by chrome binary.\nUsually, these errors can be fixed by pre-installing the browser on the specific distribution. Here is a list of the steps needed for the most common distributions.\nUbuntu\n\nWith snap:\n```sh\nsudo snap install chromium\n```\n\nWithout snap:\n```sh\nsudo apt update\nsudo snap refresh\nsudo apt install zip curl wget git\nsudo snap install golang --classic\nwget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | sudo apt-key add - \nsudo sh -c 'echo \"deb http://dl.google.com/linux/chrome/deb/ stable main\" \u003e\u003e /etc/apt/sources.list.d/google.list'\nsudo apt update \nsudo apt install google-chrome-stable\n```\n\nIn case you are unable to install the browser, or want to install only the minimum required dependencies, run the following command:\n```\nsudo apt-get install libnss3 libgconf-2-4\n```\n\nIf you encounter an error similar to \"libnss3.so: cannot open shared object file: No such file or directory,\" try running the following command to install the dev version:\n\n```\nsudo apt-get install libnss3-dev\n```\n\nError type examples:\n```\nError:      \tExpected nil, but got: \u0026errors.errorString{s:\"[launcher] Failed to launch the browser, the doc might help https://go-rod.github.io/#/compatibility?id=os: /root/.cache/rod/browser/chromium-1018003/chrome-linux/chrome: error while loading shared libraries: libnss3.so: cannot open shared object file: No such file or directory\\n\"}\n```\n```\ncould not create browser\n```\n```\nCommand '/usr/bin/chromium-browser' requires the chromium snap to be installed.\nPlease install it with:\nsnap install chromium\n```\n\n```"
    }
  ]
}